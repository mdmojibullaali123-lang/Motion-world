<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container { position: absolute; bottom: 10px; right: 10px; z-index: 2; opacity: 0.5; transform: scaleX(-1); }
        #instructions { position: absolute; top: 10px; left: 10px; z-index: 3; pointer-events: none; }
        .gesture-box { background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; margin-top: 5px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="instructions">
    <div class="gesture-box">
        <h2>Hand Gestures Control</h2>
        <p>‚úåÔ∏è <b>2 Fingers:</b> Heart Shape</p>
        <p>ü§ü <b>3 Fingers:</b> Text "Sanooo"</p>
        <p>üññ <b>4 Fingers:</b> Text "Ali"</p>
        <p>‚úã <b>5 Fingers:</b> "Sanooo & Ali"</p>
        <p>Current: <span id="current-gesture" style="color: yellow;">Waiting...</span></p>
    </div>
</div>

<div id="canvas-container"></div>
<video id="input-video" style="display:none"></video>

<script type="module">
    import * as THREE from 'three';

    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    camera.position.z = 50;

    // --- PARTICLE SYSTEM VARIABLES ---
    let particles;
    let particleGeometry;
    let targetPositions = [];
    const particleCount = 7000; // Thoda badha diya text clear dikhne ke liye
    let currentShapeType = 'heart';
    
    // Hand Tracking Data
    let handPos = { x: 0, y: 0, z: 0 };
    let isPinching = false;
    let detectedFingers = 0;

    // --- INIT PARTICLES ---
    function initParticles() {
        particleGeometry = new THREE.BufferGeometry();
        
        const posArray = new Float32Array(particleCount * 3);
        const colorArray = new Float32Array(particleCount * 3);

        for(let i=0; i<particleCount; i++) {
            posArray[i*3] = (Math.random() - 0.5) * 100;
            posArray[i*3+1] = (Math.random() - 0.5) * 100;
            posArray[i*3+2] = (Math.random() - 0.5) * 100;

            colorArray[i*3] = 1;
            colorArray[i*3+1] = 1;
            colorArray[i*3+2] = 1;
            
            targetPositions.push({x: posArray[i*3], y: posArray[i*3+1], z: posArray[i*3+2]});
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

        const material = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particles = new THREE.Points(particleGeometry, material);
        scene.add(particles);
        
        setShape('heart');
    }

    // --- SHAPE GENERATORS ---
    function setShape(type) {
        if (currentShapeType === type) return; // Agar same shape hai toh repeat mat karo
        currentShapeType = type;
        document.getElementById('current-gesture').innerText = type.toUpperCase();

        let newTargets = [];
        
        if (type === 'heart') {
            for (let i = 0; i < particleCount; i++) {
                let t = Math.random() * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 10;
                newTargets.push({x: x, y: y, z: z});
            }
        } 
        else if (type === 'Sanooo' || type === 'Ali' || type === 'SanoooAli') {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 500;
            canvas.height = 250;
            ctx.fillStyle = 'black';
            ctx.fillRect(0,0,500,250);
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (type === 'SanoooAli') {
                ctx.font = 'bold 60px Arial';
                ctx.fillText("Sanooo", 250, 80);
                ctx.fillText("&", 250, 130);
                ctx.fillText("Ali", 250, 180);
            } else {
                ctx.font = 'bold 100px Arial';
                ctx.fillText(type, 250, 125);
            }

            const imgData = ctx.getImageData(0, 0, 500, 250);
            const data = imgData.data;
            let validPoints = [];

            for(let y=0; y<250; y+=2) {
                for(let x=0; x<500; x+=2) {
                    if(data[(y * 500 + x) * 4] > 128) {
                        validPoints.push({
                            x: (x - 250) * 0.15,
                            y: -(y - 125) * 0.15,
                            z: 0
                        });
                    }
                }
            }

            for(let i=0; i<particleCount; i++) {
                if(validPoints.length > 0) {
                    const p = validPoints[i % validPoints.length];
                    newTargets.push({x: p.x, y: p.y, z: p.z});
                } else {
                    newTargets.push({x: (Math.random()-0.5)*50, y: (Math.random()-0.5)*50, z: (Math.random()-0.5)*50});
                }
            }
        }

        targetPositions = newTargets;
    }

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const positionsAttr = particles.geometry.attributes.position;
        const colorsAttr = particles.geometry.attributes.color;

        const interactX = -handPos.x * 40;
        const interactY = -handPos.y * 30;

        for (let i = 0; i < particleCount; i++) {
            let tx = targetPositions[i].x + interactX;
            let ty = targetPositions[i].y + interactY;
            let tz = targetPositions[i].z;

            // Movement logic
            const currentX = positionsAttr.getX(i);
            const currentY = positionsAttr.getY(i);
            const currentZ = positionsAttr.getZ(i);

            positionsAttr.setXYZ(i, 
                currentX + (tx - currentX) * 0.08,
                currentY + (ty - currentY) * 0.08,
                currentZ + (tz - currentZ) * 0.08
            );

            // Dynamic Colors
            if (currentShapeType === 'heart') {
                colorsAttr.setXYZ(i, 1, 0.2, 0.4); // Pinkish Red
            } else {
                // Gold/Blue gradient for text
                const r = 0.5 + Math.sin(time * 2 + tx * 0.1) * 0.5;
                colorsAttr.setXYZ(i, r, 0.8, 1.0);
            }
        }

        particles.rotation.y = Math.sin(time * 0.5) * 0.2;
        positionsAttr.needsUpdate = true;
        colorsAttr.needsUpdate = true;
        renderer.render(scene, camera);
    }

    // --- MEDIAPIPE & FINGER COUNTING ---
    const videoElement = document.getElementById('input-video');

    function countFingers(landmarks) {
        let count = 0;
        
        // Thumb (Check x-distance relative to logic)
        // Simple logic: if thumb tip is far from index base (MCP), it's open
        const thumbTip = landmarks[4];
        const indexMCP = landmarks[5]; // Index knuckle
        const thumbDist = Math.sqrt(Math.pow(thumbTip.x - indexMCP.x, 2) + Math.pow(thumbTip.y - indexMCP.y, 2));
        if (thumbDist > 0.15) count++; // Thumb open threshold

        // Fingers: Index(8), Middle(12), Ring(16), Pinky(20)
        // Check if Tip Y is less than PIP Y (Finger is up)
        if (landmarks[8].y < landmarks[6].y) count++;   // Index
        if (landmarks[12].y < landmarks[10].y) count++; // Middle
        if (landmarks[16].y < landmarks[14].y) count++; // Ring
        if (landmarks[20].y < landmarks[18].y) count++; // Pinky

        return count;
    }
    
    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // Track Hand Center
            handPos.x = landmarks[9].x - 0.5;
            handPos.y = landmarks[9].y - 0.5;

            // Count Fingers
            let fingers = countFingers(landmarks);
            
            // Logic map as requested
            if (fingers === 2) setShape('heart');
            else if (fingers === 3) setShape('Sanooo');
            else if (fingers === 4) setShape('Ali');
            else if (fingers === 5) setShape('SanoooAli');
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();

    initParticles();
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
