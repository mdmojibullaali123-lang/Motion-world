<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Hand Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container { position: absolute; bottom: 10px; right: 10px; z-index: 2; opacity: 0.5; transform: scaleX(-1); }
        #instructions { position: absolute; top: 10px; left: 10px; z-index: 3; pointer-events: none; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="instructions">
    <h2>Interactive Particle System</h2>
    <p>üñê Open Palm: Particles Floating</p>
    <p>ü§è Pinch (Index+Thumb): Collapse/Expand Particles</p>
    <p>üëã Move Hand: Move Particle Center</p>
    <p>Keyboard '1': Heart | '2': Saturn | '3': Text "Sanooo" | '4': Text "Ali"</p>
</div>

<div id="canvas-container"></div>
<video id="input-video" style="display:none"></video>
<canvas id="output-canvas" width="320" height="240" style="position:absolute; bottom:10px; right:10px; width:160px; height:120px; border:1px solid white;"></canvas>

<script type="module">
    import * as THREE from 'three';

    // --- THREE.JS SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    camera.position.z = 50;

    // --- PARTICLE SYSTEM VARIABLES ---
    let particles;
    let particleGeometry;
    let positions = [];
    let targetPositions = [];
    let colors = [];
    const particleCount = 6000; // Total particles
    
    // Hand Tracking Data
    let handPos = { x: 0, y: 0, z: 0 };
    let isPinching = false;
    let pinchDistance = 0;

    // --- INIT PARTICLES ---
    function initParticles() {
        particleGeometry = new THREE.BufferGeometry();
        
        const posArray = new Float32Array(particleCount * 3);
        const colorArray = new Float32Array(particleCount * 3);

        for(let i=0; i<particleCount; i++) {
            posArray[i*3] = (Math.random() - 0.5) * 100;
            posArray[i*3+1] = (Math.random() - 0.5) * 100;
            posArray[i*3+2] = (Math.random() - 0.5) * 100;

            colorArray[i*3] = 1;
            colorArray[i*3+1] = 1;
            colorArray[i*3+2] = 1;
            
            // Initial target is random sphere
            targetPositions.push({x: posArray[i*3], y: posArray[i*3+1], z: posArray[i*3+2]});
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

        const material = new THREE.PointsMaterial({
            size: 0.6,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        particles = new THREE.Points(particleGeometry, material);
        scene.add(particles);
        
        // Default Shape
        setShape('heart');
    }

    // --- SHAPE GENERATORS ---
    
    function setShape(type) {
        let newTargets = [];
        
        if (type === 'heart') {
            for (let i = 0; i < particleCount; i++) {
                // Heart Formula
                let t = Math.random() * Math.PI * 2;
                let u = Math.random() * Math.PI * 2; // Extra randomness for volume
                
                // 2D Heart curve extended to 3D
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 10; // Thickness

                newTargets.push({x: x, y: y, z: z});
            }
        } 
        else if (type === 'saturn') {
            for (let i = 0; i < particleCount; i++) {
                if (i < particleCount * 0.4) {
                    // Planet Body (Sphere)
                    let theta = Math.random() * Math.PI * 2;
                    let phi = Math.acos((Math.random() * 2) - 1);
                    let r = 10;
                    newTargets.push({
                        x: r * Math.sin(phi) * Math.cos(theta),
                        y: r * Math.sin(phi) * Math.sin(theta),
                        z: r * Math.cos(phi)
                    });
                } else {
                    // Rings (Disc)
                    let theta = Math.random() * Math.PI * 2;
                    let r = 15 + Math.random() * 10;
                    newTargets.push({
                        x: r * Math.cos(theta),
                        y: (Math.random() - 0.5) * 2, // Thin rings
                        z: r * Math.sin(theta)
                    });
                }
            }
        }
        else if (type === 'Sanooo' || type === 'Ali') {
            // Text Generation via 2D Canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 400;
            canvas.height = 200;
            ctx.fillStyle = 'black';
            ctx.fillRect(0,0,400,200);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(type, 200, 100);

            const imgData = ctx.getImageData(0, 0, 400, 200);
            const data = imgData.data;
            let validPoints = [];

            // Find white pixels
            for(let y=0; y<200; y+=2) {
                for(let x=0; x<400; x+=2) {
                    const index = (y * 400 + x) * 4;
                    if(data[index] > 128) { // If pixel is bright
                        validPoints.push({
                            x: (x - 200) * 0.2, // Scale down
                            y: -(y - 100) * 0.2, // Flip Y
                            z: 0
                        });
                    }
                }
            }

            // Assign points to particles
            for(let i=0; i<particleCount; i++) {
                if(validPoints.length > 0) {
                    const p = validPoints[i % validPoints.length];
                    newTargets.push({x: p.x, y: p.y, z: p.z});
                } else {
                    newTargets.push({x: 0, y: 0, z: 0});
                }
            }
        }

        targetPositions = newTargets;
    }

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const positionsAttr = particles.geometry.attributes.position;
        const colorsAttr = particles.geometry.attributes.color;

        // Interaction Logic
        // Map hand X/Y (-1 to 1) to Scene coords
        const interactX = -handPos.x * 40; // Inverse X for mirror effect
        const interactY = -handPos.y * 30;

        for (let i = 0; i < particleCount; i++) {
            let tx = targetPositions[i].x + interactX;
            let ty = targetPositions[i].y + interactY;
            let tz = targetPositions[i].z;

            // Explosion/Expansion effect on pinch
            if (isPinching) {
                const dx = positionsAttr.getX(i) - interactX;
                const dy = positionsAttr.getY(i) - interactY;
                const dz = positionsAttr.getZ(i);
                
                // Push particles away
                tx += dx * 2;
                ty += dy * 2;
                tz += dz * 2;
                
                // Change color to Red on pinch
                colorsAttr.setXYZ(i, 1, 0.2, 0.2); 
            } else {
                // Restore colors over time
                const r = 0.5 + Math.sin(time + tx*0.1) * 0.5;
                const g = 0.5 + Math.cos(time + ty*0.1) * 0.5;
                const b = 1.0;
                colorsAttr.setXYZ(i, r, g, b);
            }

            // Lerp (Smooth movement)
            const currentX = positionsAttr.getX(i);
            const currentY = positionsAttr.getY(i);
            const currentZ = positionsAttr.getZ(i);

            positionsAttr.setXYZ(i, 
                currentX + (tx - currentX) * 0.05,
                currentY + (ty - currentY) * 0.05,
                currentZ + (tz - currentZ) * 0.05
            );
        }

        particles.rotation.y = time * 0.1; // Gentle rotation
        positionsAttr.needsUpdate = true;
        colorsAttr.needsUpdate = true;
        renderer.render(scene, camera);
    }

    // --- MEDIAPIPE HANDS SETUP ---
    const videoElement = document.getElementById('input-video');
    
    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // Index Tip (8) and Thumb Tip (4)
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];
            
            // Calculate center of interaction
            handPos.x = (indexTip.x + thumbTip.x) / 2 - 0.5;
            handPos.y = (indexTip.y + thumbTip.y) / 2 - 0.5;

            // Calculate Distance (Pinch)
            const d = Math.sqrt(
                Math.pow(indexTip.x - thumbTip.x, 2) + 
                Math.pow(indexTip.y - thumbTip.y, 2)
            );
            
            isPinching = d < 0.05; // Threshold for pinch
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();

    // Init Logic
    initParticles();
    animate();

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Keyboard Controls
    window.addEventListener('keydown', (e) => {
        if(e.key === '1') setShape('heart');
        if(e.key === '2') setShape('saturn');
        if(e.key === '3') setShape('Sanooo');
        if(e.key === '4') setShape('Ali');
    });

</script>
</body>
</html>
